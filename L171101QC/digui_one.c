#include  <stdio.h>
/*
递归:函数内调用自己.实现函数调用的递推和回退
调用函数时,从最外层函数调用到最内层函数 此过程称为递推
函数结束返回,从最内层函数结束返回到最外层函数结束,此过程称为回退
递归=递推+回退
每次函数调用都会分配一个独立局部栈,递归每层的函数调用都会分配独立局部栈.
与栈的先进后出符合
如何实现递归:
1.函数调用时,前一层与后一层调用必定存在一种关系
2.必须找到递推的结束点.否则就是死递归
3.实现递归算法时,应该考虑的是过程而非细节
递归优点和缺点:
1.优点:算法实现简单化
2.缺点:占用更多栈空间,执行效率较低
递归注意事项:
1.不能用全局变量递归
*/
//1.1+2+3+4+..+n 之和?
int  fun1(int n)
{
	if(n==1)
		return 1;
    else
    	return fun1(n-1)+n;
}
//2.上台阶:一次只能跨一个或跨两个,假设现有n台阶楼梯
//n=7计算出有多少种上法
int  fun2(int n)
{
	if(n==1)
		return 1;
	if(n==2)
		return 2;
	return fun2(n-1)+fun2(n-2);
}
//3.不使用任何变量编写strlen 函数
int  fun3(char*  ch)
{
	if(*ch==0)
		return 0;
	return fun3(++ch)+1;
}
//4.有5个人坐在一起,问第5个人多少岁?他说比第4个人大两岁问第4个人岁数,
//他说比第3个人大两岁问第3个人,又说比第2个人大两岁问第2个人,
//说比第1个人大两岁最后问第1个人,他说是10岁请问第5个人多大
int  fun4(int n)
{
	if(n==1)
		return 10;
	return  fun4(n-1)+2;
}

//5.用递归方法求n!
int  fun5(int n)
{
	if(n==1)
		return 1;
	return fun5(n-1)*n;
}
//6.求数列:y=f(x)=f(x-1)+f(x-2) 的指定的第x项对应的y值是多少? 
//条件:f(1)=f(2)=1; x必须是非0的正整数
int fun6(int x)
{
	if(x==1 ||x==2)
		return 1;
	return fun6(x-1)+fun6(x-2);
}

//
void e(int n)
{
  if(n>0)
  {
    e(--n);
    printf("%d" , n);
    e(--n);
  }
}

//7.采用递归方法将任一整数转换为二进制形式
void  fun7(int data)
{
	if(data>0)
	{
		fun7(data/2);
		printf("%d",data%2);
	}
}
//8.用递归法将一个整数n转换成字符串（例如输入4679，
//应输出字符串“4679”），n为不确定数，可以是位数不超过5，
//且数值在-32768~32767之间和任意整数
void  fun8(int n)
{
	if(n>0)
	{
		fun8(n/10);
		printf("%c",n%10+'0');
	}
}
//9.利用递归函数调用方式,
//将所输入的一行字符,以相反顺序打印出来(不能用数组)
void   fun9()
{
	char ch;
	scanf("%c",&ch);
	if(ch!='\n')
	{
		fun9();
		printf("%c",ch);
	}
}
//10.汉诺塔是根据一个传说形成的一个问题。
//汉诺塔（又称河内塔）问题是源于印度一个古老传说的益智玩具。
//大梵天创造世界的时候做了三根金刚石柱子，
//在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。
//大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放
//在另一根柱子上。并且规定，在小圆盘上不能放大圆盘
//，在三根柱子之间一次只能移动一个圆盘(赵磊)



int main(int argc, char const *argv[])
{
	 // int a;
  //    a=3;
  //    e(a);

	//int ret=fun1(100);
	//int ret=fun2(7);
	//int ret=fun3("abcd");
	//int ret=fun4(5);
	//int ret=fun5(3);
	//int ret=fun6(6);	
    //fun7(14);
    //fun8(4679);
    fun9();
	//printf("%d\n",ret);
	return 0;
}