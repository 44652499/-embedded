#include <stdio.h>
#include <limits.h>
/*
位运算符号:&  |  ~ ^ <<  >>
三个编码:
原码
反码
补码
无符号: 原码=反码=补码
有符号:
原码=abs(有符号)
反码=原码取反
补码=反码+1
计算底层只使用补码
-3  计算存储补码:0  0011   
                 1  1100   
                 1  101(补码)
底层1 ..  101 表示数是:
除开符号位其它位取反 1  .. 010   +1   1  .. 011      -3
+0 -0存储补码是?
+0:0  000
-0:0  000   1  111  +1   0  000
&: 1&1  1&0  0&0  0&1

^:1^1=0  0^1=1  0^0=0

>>:右移,舍弃低位,高位补0或1.补符号位
<<:左移舍弃高位,低位补0

总结使用符号时考虑符号三个特性:
1.符号优先级
2.符号结合性(左结合  右结合)
3.符号元数(操作数个数)
*/

int main(int argc, char const *argv[])
{
	//使用位运算符号时,其操作都要转换底层二进制补码
	//int  a=3;
	//int  b=5;
	//printf("%d\n",a&b);
	//a=0 0011
	//b=0 0101
	//a&b=0  0001
	// int b=-5;
	// printf("%d\n",a&b);
	//a=0 0011
	//b=0 0101     1  1010     +1   1  1011
	//a&b=0   0011   
 //    int a=-3;
	// int b=-5;
	// printf("%d\n",a&b);
	//a=0 0011   1  1100  +1   1 1101
	//b=0 0101   1  1010  +1   1 1011
	//a&b=1  1001(补码最高位1 负数)
	//1  0110  +1   1 0111  -7

	// int a=-3;
	// int b=-5;
	// printf("%d\n",a^b);
	//a=0 0011   1  1100  +1   1 1101
	//b=0 0101   1  1010  +1   1 1011
	//a^b= 0 0110

	//最高效交换任意两个整数值
	// int a=INT_MAX;
	// int b=INT_MAX;
	// a=a^b;
	// b=a^b;
	// a=a^b;
	// printf("%d\t%d\n",a,b);

	//int a=-9;
	//printf("%d\n",a>>3);
	//a=0 0101   1  1010  +1   1 1011
	//a>>3:  1  1111     1 0000  +1   1  0001
	// int a=-8;
	// printf("%d\n",a>>2);
	//右移n位,相当于除以2^n

	//int a=-9;
	//printf("%d\n",a<<3);
	//左移n位,相当于乘以2^n
	//a=0  1001   1  0110   +1  1  0111
	//a<<3   1  1011 1000
	//1   0100  0111  +1   1  0100 1000

	int a=3;
	printf("%d\n",a<<3+2);//a<<(3+2)
	return 0;
}

/*
优先级	运算符	结合律
1	( )  [ ]  ->  .	从左至右
2	!  ~  ++  --  (类型) sizeof +  -  *  &	从右至左
3	*  /  %	从左至右
4	+  -	从左至右
5	<<  >>	从左至右
6	<   <=   >  >=	从左至右
7	==  !=	从左至右
8	&	从左至右
9	^	从左至右
10	|	从左至右
11	&&	从左至右
12	||	从左至右
13	?:	从右至左
14	=  +=  -=  *=  /=  %=  &=  ^= |=  <<=  >>=	从左至右
15	,   
     "运算符号">">> <<">"比较符号">"& ^ |">"逻辑符号">"?">"赋值符号">","
*/